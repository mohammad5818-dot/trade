import ccxt
import pandas as pd
import talib
import time
import datetime
import pytz
import sys
import requests
import traceback
import numpy as np
import os
import json
import copy

# ======================================================================
# 1. ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ú©ÙˆÛŒÙ†Ú©Ø³ Ùˆ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§ØµÙ„ÛŒ (Ø§Ø² Environment Variables Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯)
# ======================================================================

# ğŸ”’ğŸ”‘ Ø§Ù…Ù†ÛŒØª: Ú©Ù„ÛŒØ¯Ù‡Ø§ Ø§Ø² Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ù…Ø­ÛŒØ·ÛŒ (COINEX_API_KEY, COINEX_SECRET, etc.) Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
API_KEY = os.getenv("COINEX_API_KEY")
SECRET = os.getenv("COINEX_SECRET")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

if not all([API_KEY, SECRET, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID]):
    print("âŒ Ø®Ø·Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ: Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ API ÛŒØ§ ØªÙ„Ú¯Ø±Ø§Ù… Ø¯Ø± Environment Variables ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯.")
    print("Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒÙ„ trading_bot.service Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ùˆ Ù…Ù‚Ø§Ø¯ÛŒØ± Environment Ø±Ø§ Ù¾Ø± Ú©Ù†ÛŒØ¯.")
    sys.exit()

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¹Ù…ÙˆÙ…ÛŒ Ùˆ Ø±ÛŒØ³Ú©
LIVE_TRADING = False                  # ğŸ’¡ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø¨Ø±Ø§ÛŒ ØªØ³Øª Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ: FALSE
LEVERAGE = 5.0                        # Ø§Ù‡Ø±Ù… (Leverage)
INITIAL_CAPITAL = 40.0                # Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§ÙˆÙ„ÛŒÙ‡ Ø¯Ø± ØµÙˆØ±Øª Ù†Ø¨ÙˆØ¯Ù† ÙØ§ÛŒÙ„ ÙˆØ¶Ø¹ÛŒØª
RISK_PER_TRADE = 0.015                # Ø¯Ø±ØµØ¯ Ø±ÛŒØ³Ú© Ø¯Ø± Ù‡Ø± Ù…Ø¹Ø§Ù…Ù„Ù‡ (1.5%)

# ğŸ›¡ï¸ Ù¾Ø§Ø±Ø§Ù…ØªØ± Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ù…Ø¬Ù…ÙˆØ¹ Ù…Ø§Ø±Ø¬ÛŒÙ† Ù…ØµØ±ÙÛŒ (Ø«Ø§Ø¨Øª: 90%)
MAX_TOTAL_MARGIN_PERCENT = 0.90

# â— Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„ ÙˆØ¶Ø¹ÛŒØª Ø¯Ø± Ù…Ø­ÛŒØ· VPS
STATE_FILE = 'bot_state.json'
TEHRAN_TIMEZONE = pytz.timezone('Asia/Tehran')
TELEGRAM_API_URL = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"

# ... (Ø¨Ù‚ÛŒÙ‡ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø«Ø§Ø¨Øª) ...
TIMEFRAME = '15m'
OHLCV_LIMIT = 300
TREND_TIMEFRAME = '4h'
LONG_TERM_EMA_PERIOD = 20

SYMBOLS = [
    'BTC/USDT', 'ETH/USDT', 'SOL/USDT', 'ADA/USDT',
    'XRP/USDT', 'DOGE/USDT', 'DOT/USDT', 'LINK/USDT',
    'UNI/USDT', 'LTC/USDT',
    'BNB/USDT', 'AVAX/USDT', 'ETC/USDT', 'ATOM/USDT'
]

CORRELATION_GROUPS = {
    'BTC_Main': ['BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'LTC/USDT'],
    'SOL_Ecosystem': ['SOL/USDT', 'AVAX/USDT', 'DOT/USDT'],
    'Alt_Value': ['ADA/USDT', 'XRP/USDT', 'DOGE/USDT', 'ETC/USDT', 'ATOM/USDT', 'LINK/USDT', 'UNI/USDT']
}
MAX_GROUP_TRADES = 2

MARKET_DATA = {}
LONG_TERM_TRENDS = {}
MAX_CONCURRENT_TRADES = 7

# ... (Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØµØ±Ø§ÙÛŒ Ø«Ø§Ø¨Øª) ...
try:
    exchange = ccxt.coinex({
        'apiKey': API_KEY,
        'secret': SECRET,
        'enableRateLimit': True,
        'options': {'defaultType': 'future'}
    })

except Exception as e:
    print(f"Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ ØµØ±Ø§ÙÛŒ: {e}")
    sys.exit()

# ======================================================================
# 2. Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ Ùˆ ÙÛŒÙ„ØªØ±Ù‡Ø§ÛŒ Ù†ÙˆØ³Ø§Ù†
# ======================================================================
ATR_PERIOD = 14
RSI_PERIOD = 14
VOLUME_AVG_PERIOD = 50
MIN_VOLUME_MULTIPLIER = 1.2
EMA_TREND_PERIOD = 50

MIN_SL_PERCENT = 0.003
SPIKE_BODY_MULTIPLIER = 3.0
SPT_MIN_BODY_CHECK = True
SPT_RR_RATIO = 2.0
RSI_ADAPT_PERIOD = 200
RSI_ADAPT_LOWER_PERCENTILE = 0.10
RSI_ADAPT_UPPER_PERCENTILE = 0.90
SMART_ENTRY_ENABLED = True
SMART_ENTRY_RETRA_RATIO = 0.5
SMART_ENTRY_EXPIRY_CANDLES = 1
MAX_DAILY_LOSS_PERCENT = 0.05
MAX_LOSS_PER_SYMBOL_PERCENT = 0.03

ADX_PERIOD = 14
ADX_MIN_LEVEL = 25.0

TRAILING_ATR_MULTIPLIER = 1.5
TRAILING_BE_R_ACTIVATION = 1.0
TRAILING_R_ACTIVATION = 1.5

# Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø³Ø±Ø§Ø³Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª
CAPITAL = INITIAL_CAPITAL
RISK_AMOUNT = 0
MAX_TOTAL_MARGIN = 0
DAILY_LOSS_LIMIT = 0

Strategy_Stats_Template = {
    'TrendBreakout': {'Win': 0, 'Loss': 0, 'PnL': 0.0},
    'SPT': {'Win': 0, 'Loss': 0, 'PnL': 0.0}
}
Strategy_Stats = copy.deepcopy(Strategy_Stats_Template)

Ledger = {}
Daily_Stats = {'Total PnL': 0, 'Wins': 0, 'Losses': 0, 'WinRate': 0}
Symbol_Losses = {symbol: 0 for symbol in SYMBOLS}
Trade_Counter = 0
last_candle_timestamp = {}
current_candle = {'close': 0}
LAST_REPORT_DATE = None

# ======================================================================
# 3. ØªÙˆØ§Ø¨Ø¹ Utility, Persistence, Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª
# ======================================================================

# --- ØªÙˆØ§Ø¨Ø¹ Utility Ùˆ Persistence ---
def get_tehran_time(timestamp_ms=None):
    if timestamp_ms is None:
        dt = datetime.datetime.now(TEHRAN_TIMEZONE)
    else:
        dt = datetime.datetime.fromtimestamp(timestamp_ms / 1000.0, TEHRAN_TIMEZONE)
    return dt.strftime('%Y-%m-%d %H:%M:%S')

def send_telegram_message(message):
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID: return
    payload = {'chat_id': TELEGRAM_CHAT_ID, 'text': message, 'parse_mode': 'Markdown'}
    try:
        requests.post(TELEGRAM_API_URL, data=payload, timeout=15)
    except requests.exceptions.RequestException as e:
        print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… ØªÙ„Ú¯Ø±Ø§Ù…: {e}")

def get_real_capital_from_exchange():
    global exchange, CAPITAL
    if not LIVE_TRADING:
        return CAPITAL

    try:
        balance = exchange.fetch_balance({'type': 'future'})
        if 'USDT' in balance and 'total' in balance['USDT']:
             real_capital = balance['USDT']['total']
             return max(0.0, real_capital)
        return 0.0
    except Exception as e:
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² ØµØ±Ø§ÙÛŒ: {e}")
        return 0.0

def save_state():
    global Ledger, Daily_Stats, Symbol_Losses, Trade_Counter, Strategy_Stats, LAST_REPORT_DATE, CAPITAL

    def to_float(value):
        if isinstance(value, (np.float64, np.float32)):
            return float(value)
        return value

    serializable_ledger = {}
    for sym, trade in Ledger.items():
        serializable_trade = {k: to_float(v) for k, v in trade.items()}
        if 'trades' in serializable_trade:
             serializable_trade['trades'] = [
                 {k: to_float(v) for k, v in t.items()}
                 for t in serializable_trade['trades']
             ]
        serializable_ledger[sym] = serializable_trade

    serializable_strategy_stats = {
        k: {sk: to_float(sv) for sk, sv in v.items()}
        for k, v in Strategy_Stats.items()
    }

    data = {
        'CAPITAL': CAPITAL,
        'Ledger': serializable_ledger,
        'Daily_Stats': Daily_Stats,
        'Symbol_Losses': Symbol_Losses,
        'Trade_Counter': Trade_Counter,
        'Strategy_Stats': serializable_strategy_stats,
        'LAST_REPORT_DATE': LAST_REPORT_DATE,
        'Last_Save_Time': get_tehran_time()
    }

    try:
        with open(STATE_FILE, 'w') as f:
            json.dump(data, f, indent=4)
    except Exception as e:
        print(f"[{get_tehran_time()}] âŒâŒâŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ: Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯! (Ø¯Ù„ÛŒÙ„: {e})")

def recalculate_risk_parameters():
    global RISK_AMOUNT, MAX_TOTAL_MARGIN, DAILY_LOSS_LIMIT, CAPITAL

    if CAPITAL <= 0:
        CAPITAL = INITIAL_CAPITAL

    RISK_AMOUNT = CAPITAL * RISK_PER_TRADE
    MAX_TOTAL_MARGIN = CAPITAL * MAX_TOTAL_MARGIN_PERCENT
    DAILY_LOSS_LIMIT = CAPITAL * MAX_DAILY_LOSS_PERCENT

    print(f"[{get_tehran_time()}] ğŸ”„ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø±ÛŒØ³Ú© Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯. Ø±ÛŒØ³Ú© Ø¯Ù„Ø§Ø±ÛŒ: ${round(RISK_AMOUNT, 2)}. Ø³Ù‚Ù Ù…Ø§Ø±Ø¬ÛŒÙ†: ${round(MAX_TOTAL_MARGIN, 2)}")

def load_state():
    global Ledger, Daily_Stats, Symbol_Losses, Trade_Counter, Strategy_Stats, LAST_REPORT_DATE, CAPITAL

    CAPITAL = INITIAL_CAPITAL

    if not os.path.exists(STATE_FILE):
        print(f"[{get_tehran_time()}] ğŸ’¡ ÙØ§ÛŒÙ„ ÙˆØ¶Ø¹ÛŒØª ({STATE_FILE}) ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯.")
        recalculate_risk_parameters()
        return

    try:
        with open(STATE_FILE, 'r') as f:
            data = json.load(f)

            CAPITAL = data.get('CAPITAL', INITIAL_CAPITAL)

            Ledger = data.get('Ledger', {})
            Daily_Stats = data.get('Daily_Stats', {'Total PnL': 0, 'Wins': 0, 'Losses': 0, 'WinRate': 0})
            Symbol_Losses = data.get('Symbol_Losses', {symbol: 0 for symbol in SYMBOLS})
            Trade_Counter = data.get('Trade_Counter', 0)

            loaded_stats = data.get('Strategy_Stats', Strategy_Stats_Template)
            for strategy, stats in loaded_stats.items():
                if strategy in Strategy_Stats:
                    Strategy_Stats[strategy] = stats

            LAST_REPORT_DATE = data.get('LAST_REPORT_DATE', None)

            Ledger = {sym: trade for sym, trade in Ledger.items() if trade['status'] in ['OPEN', 'PENDING']}

            real_balance = get_real_capital_from_exchange()
            if LIVE_TRADING and real_balance > 0 and abs(CAPITAL - real_balance) > 1.0:
                capital_change = real_balance - CAPITAL
                if capital_change > 0: change_reason = "ÙˆØ§Ø±ÛŒØ² Ø¯Ø³ØªÛŒ"
                else: change_reason = "Ø¨Ø±Ø¯Ø§Ø´Øª Ø¯Ø³ØªÛŒ"

                print(f"[{get_tehran_time()}] âš ï¸ CAPITAL Ø¯Ø§Ø®Ù„ÛŒ ({round(CAPITAL, 2)}$) Ø¨Ø§ Ù…ÙˆØ¬ÙˆØ¯ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ ØµØ±Ø§ÙÛŒ ({round(real_balance, 2)}$) Ù…ØºØ§ÛŒØ±Øª Ø¯Ø§Ø±Ø¯. ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯. Ø¯Ù„ÛŒÙ„: {change_reason}")
                CAPITAL = real_balance

            recalculate_risk_parameters()

            print(f"[{get_tehran_time()}] âœ… ÙˆØ¶Ø¹ÛŒØª Ø±Ø¨Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯. Ø³Ø±Ù…Ø§ÛŒÙ‡ ÙØ¹Ù„ÛŒ: ${round(CAPITAL, 2)}")

    except Exception as e:
        print(f"[{get_tehran_time()}] âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª: {e}. Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.")
        recalculate_risk_parameters()


def update_capital_after_trade(pnl):
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ CAPITAL Ù¾Ø³ Ø§Ø² Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ù…Ø¹Ø§Ù…Ù„Ù‡."""
    global CAPITAL
    CAPITAL += pnl
    recalculate_risk_parameters()
    print(f"[{get_tehran_time()}] ğŸ“ˆ Ø³Ø±Ù…Ø§ÛŒÙ‡ Ú©Ù„ Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯: ${round(CAPITAL, 2)} (+/- ${round(pnl, 2)})")

# --- ØªÙˆØ§Ø¨Ø¹ Core Logic Ùˆ Risk Management ---

def load_market_params():
    """Ø¯Ø±ÛŒØ§ÙØª Ùˆ Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¶Ø±ÙˆØ±ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø§Ø² ØµØ±Ø§ÙÛŒ."""
    global MARKET_DATA
    current_time = get_tehran_time()
    print(f"[{current_time}] ğŸŒ Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±...")

    try:
        markets = exchange.load_markets()
        SYMBOLS_TEMP = SYMBOLS.copy()
        SYMBOLS.clear()
        for symbol in SYMBOLS_TEMP:
            if symbol not in markets:
                print(f"[{current_time}] âŒ Ù†Ù…Ø§Ø¯ {symbol} Ø¯Ø± ØµØ±Ø§ÙÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯. Ø­Ø°Ù Ø´Ø¯.")
                continue
            SYMBOLS.append(symbol)
            market = markets[symbol]
            base_currency = market['base']
            quote_currency = market['quote']

            # Ø¯Ù‚Øª Ø§Ø¹Ø´Ø§Ø± (Precision) Ùˆ Ø­Ø¯Ø§Ù‚Ù„/Ø­Ø¯Ø§Ú©Ø«Ø± Ù…Ù‚Ø§Ø¯ÛŒØ±
            precision_amount = market['precision']['amount']
            precision_price = market['precision']['price']
            min_amount = market['limits']['amount']['min']
            min_usd = market['limits']['cost']['min'] if 'cost' in market['limits'] else 10.0

            MARKET_DATA[symbol] = {
                'base': base_currency,
                'quote': quote_currency,
                'precision_amount': precision_amount,
                'precision_price': precision_price,
                'min_amount': min_amount,
                'min_usd': min_usd
            }
        print(f"[{current_time}] âœ… Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ {len(SYMBOLS)} Ù†Ù…Ø§Ø¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.")
        return True
    except Exception as e:
        print(f"[{current_time}] âŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±: {e}")
        return False

def calculate_position_size(symbol, entry_price, sl_price, risk_amount_usd):
    """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø§ÛŒØ² Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ ÙØ§ØµÙ„Ù‡ SL Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú©."""

    market_info = MARKET_DATA.get(symbol)
    if not market_info:
        return 0.0

    sl_distance_percent = abs(entry_price - sl_price) / entry_price

    # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ SL ÙØ§ØµÙ„Ù‡ Ù…Ù†Ø·Ù‚ÛŒ Ø¯Ø§Ø±Ø¯
    if sl_distance_percent < MIN_SL_PERCENT:
        print(f"[{get_tehran_time()}] âš ï¸ SL Ø¨Ø±Ø§ÛŒ {symbol} Ø®ÛŒÙ„ÛŒ Ú©ÙˆÚ†Ú© Ø§Ø³Øª ({sl_distance_percent*100:.2f}%).")
        return 0.0

    # 1. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ù‚Ø¯Ø§Ø± Ø¯Ù„Ø§Ø±ÛŒ (Position Value)
    position_value_usd = risk_amount_usd / sl_distance_percent

    # 2. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø§Ø±Ø¬ÛŒÙ† Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²
    margin_needed = position_value_usd / LEVERAGE

    # 3. Ú†Ú© Ú©Ø±Ø¯Ù† Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ú©Ù„ Ù…Ø§Ø±Ø¬ÛŒÙ†
    current_total_margin = sum(trade['margin'] for trade in Ledger.values() if trade['status'] in ['OPEN', 'PENDING'] and trade.get('strategy') != 'UNMANAGED')

    if (current_total_margin + margin_needed) > MAX_TOTAL_MARGIN:
        return 0.0

    # 4. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø§ÛŒØ² (Size) Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ù‚Ø¯Ø§Ø± Ø¯Ù„Ø§Ø±ÛŒ Ùˆ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯
    size = position_value_usd / entry_price

    # 5. Ø§Ø¹Ù…Ø§Ù„ Ø¯Ù‚Øª Ø§Ø¹Ø´Ø§Ø± ØµØ±Ø§ÙÛŒ
    precision = market_info['precision_amount']
    size = round(size, precision)

    # 6. Ú†Ú© Ú©Ø±Ø¯Ù† Ø­Ø¯Ø§Ù‚Ù„ Ø³Ø§ÛŒØ² (Min Amount)
    min_amount = market_info['min_amount']
    min_usd_req = market_info['min_usd']

    if size < min_amount or (size * entry_price) < min_usd_req:
        return 0.0

    return size

def check_correlation_filter(symbol, side):
    """Ú†Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ø¢ÛŒØ§ ØªØ¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ù‡Ù…Ø¨Ø³ØªÚ¯ÛŒ Ø¨Ù‡ Ø³Ù‚Ù Ø®ÙˆØ¯ Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª."""
    group_name = None
    for group, symbols_in_group in CORRELATION_GROUPS.items():
        if symbol in symbols_in_group:
            group_name = group
            break

    if not group_name:
        return True, "Ø¨Ø¯ÙˆÙ† Ú¯Ø±ÙˆÙ‡ Ù‡Ù…Ø¨Ø³ØªÚ¯ÛŒ"

    open_trades_in_group = sum(
        1 for sym, trade in Ledger.items()
        if trade['status'] in ['OPEN', 'PENDING'] and sym in CORRELATION_GROUPS[group_name]
    )

    if open_trades_in_group >= MAX_GROUP_TRADES:
        return False, f"Ø³Ù‚Ù Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ú¯Ø±ÙˆÙ‡ {group_name} ÙØ¹Ø§Ù„ Ø´Ø¯ ({MAX_GROUP_TRADES}/{open_trades_in_group+1})"

    return True, "ØªØ§ÛŒÛŒØ¯ Ø´Ø¯"

def get_strategy_performance_report():
    """ØªÙˆÙ„ÛŒØ¯ Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ùˆ Ú©Ù„ÛŒ."""
    global Daily_Stats, Strategy_Stats, CAPITAL, INITIAL_CAPITAL

    report = "**ğŸ“Š Ú¯Ø²Ø§Ø±Ø´ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø¨Ø§Øª (Ù¾Ø§ÛŒØ§Ù† Ø±ÙˆØ²)**\n\n"
    report += f"ğŸ—“ï¸ ØªØ§Ø±ÛŒØ®: {get_tehran_time().split(' ')[0]}\n"
    report += f"ğŸ’° Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ø±ÙˆØ²: **${round(Daily_Stats['Total PnL'], 2)}**\n"
    report += f"ğŸ† Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø±Ø¯: {Daily_Stats['Wins']} | ğŸ“‰ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø®Øª: {Daily_Stats['Losses']}\n"
    total_daily_trades = Daily_Stats['Wins'] + Daily_Stats['Losses']
    daily_win_rate = (Daily_Stats['Wins'] / total_daily_trades) * 100 if total_daily_trades > 0 else 0
    report += f"ğŸ¯ Ø¯Ø±ØµØ¯ Ø¨Ø±Ø¯: **{round(daily_win_rate, 2)}%**\n"

    report += "\n**ğŸ“ˆ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒâ€ŒÙ‡Ø§ (Ø±ÙˆØ²Ø§Ù†Ù‡):**\n"
    for strategy, stats in Strategy_Stats.items():
        if stats['Win'] + stats['Loss'] > 0:
            report += f"- {strategy}: PnL=${round(stats['PnL'], 2)} (Ø¨Ø±Ø¯/Ø¨Ø§Ø®Øª: {stats['Win']}/{stats['Loss']})\n"

    report += "\n**ğŸ¦ ÙˆØ¶Ø¹ÛŒØª Ú©Ù„ÛŒ Ø³Ø±Ù…Ø§ÛŒÙ‡:**\n"
    overall_pnl = CAPITAL - INITIAL_CAPITAL
    report += f"ğŸ’µ Ø³Ø±Ù…Ø§ÛŒÙ‡ Ø§ÙˆÙ„ÛŒÙ‡: ${round(INITIAL_CAPITAL, 2)}\n"
    report += f"ğŸ’µ Ø³Ø±Ù…Ø§ÛŒÙ‡ ÙØ¹Ù„ÛŒ: **${round(CAPITAL, 2)}**\n"
    report += f"ğŸ“ˆ Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ú©Ù„ÛŒ: **${round(overall_pnl, 2)}**\n"

    return report

def reset_daily_stats():
    """Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø±ÙˆØ² Ø¬Ø¯ÛŒØ¯."""
    global Daily_Stats, Symbol_Losses, Strategy_Stats, LAST_REPORT_DATE

    Daily_Stats = {'Total PnL': 0, 'Wins': 0, 'Losses': 0, 'WinRate': 0}
    Symbol_Losses = {symbol: 0 for symbol in SYMBOLS}
    Strategy_Stats = copy.deepcopy(Strategy_Stats_Template)
    LAST_REPORT_DATE = get_tehran_time().split(' ')[0]

    print(f"[{get_tehran_time()}] ğŸ”„ Ø¢Ù…Ø§Ø± Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ø¯.")

def check_max_daily_loss():
    """Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¢ÛŒØ§ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª ÛŒØ§ Ø®ÛŒØ±."""
    global CAPITAL, DAILY_LOSS_LIMIT, exchange, SYMBOLS, Symbol_Losses, MAX_LOSS_PER_SYMBOL_PERCENT

    current_loss = 0
    if Daily_Stats['Total PnL'] < 0:
        current_loss = abs(Daily_Stats['Total PnL'])

    if current_loss >= DAILY_LOSS_LIMIT:

        telegram_msg = (
            f"**âŒğŸš¨ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ø±ÙˆØ²Ø§Ù†Ù‡ ÙØ¹Ø§Ù„ Ø´Ø¯!**\n"
            f"Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²ÛŒØ§Ù†: **${round(DAILY_LOSS_LIMIT, 2)}**\n"
            f"Ø²ÛŒØ§Ù† Ø§Ù…Ø±ÙˆØ²: **${round(current_loss, 2)}**\n"
            f"âŒ Ø±Ø¨Ø§Øª ØªØ§ ÙØ±Ø¯Ø§ ØµØ¨Ø­ (Ù¾Ø³ Ø§Ø² Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø±) Ø§Ø² ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¬Ø¯ÛŒØ¯ Ø®ÙˆØ¯Ø¯Ø§Ø±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."
        )

        # Ø¨Ø³ØªÙ† ØªÙ…Ø§Ù… Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§ÙØ¸Øª Ø§Ø² Ø³Ø±Ù…Ø§ÛŒÙ‡
        closed_count = 0
        for symbol, trade in list(Ledger.items()):
             if trade['status'] == 'OPEN' and trade.get('strategy') != 'UNMANAGED':
                # Ø¨Ø³ØªÙ† Ø¨Ø§ Ù…Ø§Ø±Ú©Øª
                try:
                    if LIVE_TRADING:
                        close_side = 'sell' if trade['side'] == 'LONG' else 'buy'
                        exchange.create_order(symbol, 'market', close_side, trade['size'])
                        cancel_all_native_orders(symbol)

                    # ğŸ’¡ Ø¯Ø± Ø­Ø§Ù„Øª Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒØŒ Ù¾ÙˆØ²ÛŒØ´Ù† Ø±Ø§ Ø¨Ø§ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ Ù…ÛŒâ€ŒØ¨Ù†Ø¯ÛŒÙ….
                    else:
                         current_price = exchange.fetch_ticker(symbol)['last']
                         update_ledger_simulated(symbol, trade['side'], trade['size'], trade['entry'], trade['sl'], trade['tp'], 'CLOSED', trade['strategy'], trade['id'], time_exit=current_price)

                    Ledger.pop(symbol)
                    closed_count += 1
                except Exception as e:
                    print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø³ØªÙ† Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ {symbol}: {e}")

        if closed_count > 0:
            telegram_msg += f"\n**ğŸ›‘ {closed_count} Ù¾ÙˆØ²ÛŒØ´Ù† Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯.**"

        send_telegram_message(telegram_msg)
        print(f"[{get_tehran_time()}] ğŸš¨ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ø±ÙˆØ²Ø§Ù†Ù‡ ÙØ¹Ø§Ù„ Ø´Ø¯.")

        # ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒÛŒ Ú©Ù‡ Ø¨Ù‡ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ù…Ø§Ù‡Ø§Ù†Ù‡/Ù‡ÙØªÚ¯ÛŒ Ø±Ø³ÛŒØ¯Ù‡â€ŒØ§Ù†Ø¯
        SYMBOLS_TEMP = SYMBOLS.copy()

        def filter_symbols(sym):
            # Ø§ÛŒÙ† ÙÛŒÙ„ØªØ± Ù†Ù…Ø§Ø¯Ù‡Ø§ÛŒÛŒ Ø±Ø§ Ú©Ù‡ Ø§Ø² Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ù…Ø§Ù‡Ø§Ù†Ù‡/Ù‡ÙØªÚ¯ÛŒ ÙØ±Ø§ØªØ± Ø±ÙØªÙ‡â€ŒØ§Ù†Ø¯ Ø­Ø°Ù Ù…ÛŒâ€ŒÚ©Ù†Ø¯
            # (MAX_LOSS_PER_SYMBOL_PERCENT = 3% Ø§Ø² Ú©Ù„ Ø³Ø±Ù…Ø§ÛŒÙ‡)
            if sym in Symbol_Losses and Symbol_Losses[sym] >= CAPITAL * MAX_LOSS_PER_SYMBOL_PERCENT:
                return False
            return True

        SYMBOLS = list(filter(filter_symbols, SYMBOLS_TEMP))

        if len(SYMBOLS) < len(SYMBOLS_TEMP):
             print(f"[{get_tehran_time()}] ğŸ›¡ï¸ {len(SYMBOLS_TEMP) - len(SYMBOLS)} Ù†Ù…Ø§Ø¯ Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ù‡ÙØªÚ¯ÛŒ/Ù…Ø§Ù‡Ø§Ù†Ù‡ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯Ù†Ø¯.")

        save_state()
        sys.exit() # ğŸ›‘ ØªÙˆÙ‚Ù Ù…ÙˆÙ‚Øª Ø±Ø¨Ø§Øª (ÛŒØ§ Ø§Ø¯Ø§Ù…Ù‡ Ú©Ø§Ø± Ø¨Ø¯ÙˆÙ† ÙˆØ±ÙˆØ¯ Ø¬Ø¯ÛŒØ¯)


# --- ØªÙˆØ§Ø¨Ø¹ Ù…Ø¯ÛŒØ±ÛŒØª Ø³ÙØ§Ø±Ø´Ø§Øª Ø¨ÙˆÙ…ÛŒ (ÙÙ‚Ø· Ø¯Ø± Live Trading Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯) ---

def cancel_all_native_orders(symbol):
    """Ù„ØºÙˆ ØªÙ…Ø§Ù… Ø³ÙØ§Ø±Ø´Ø§Øª ÙØ¹Ø§Ù„ TP Ùˆ SL Ø¯Ø± ØµØ±Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ ÛŒÚ© Ù†Ù…Ø§Ø¯ (ÙÙ‚Ø· Live Trading)."""
    global exchange, Ledger
    if not LIVE_TRADING or symbol not in Ledger: return

    try:
        open_orders = exchange.fetch_open_orders(symbol)

        tp_id = Ledger[symbol].get('tp_order_id')
        sl_id = Ledger[symbol].get('sl_order_id')

        cancelled_count = 0

        if sl_id:
            try:
                exchange.cancel_order(sl_id, symbol)
                Ledger[symbol].pop('sl_order_id', None)
                cancelled_count += 1
            except ccxt.OrderNotFound: Ledger[symbol].pop('sl_order_id', None)

        if tp_id:
            try:
                exchange.cancel_order(tp_id, symbol)
                Ledger[symbol].pop('tp_order_id', None)
                cancelled_count += 1
            except ccxt.OrderNotFound: Ledger[symbol].pop('tp_order_id', None)

        if cancelled_count > 0:
            print(f"[{get_tehran_time()}] ğŸš« {cancelled_count} Ø³ÙØ§Ø±Ø´ TP/SL Ø¨ÙˆÙ…ÛŒ Ø¨Ø±Ø§ÛŒ {symbol} Ù„ØºÙˆ Ø´Ø¯.")
            save_state()

    except Exception as e:
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ù„ØºÙˆ Ø³ÙØ§Ø±Ø´Ø§Øª Ø¨ÙˆÙ…ÛŒ {symbol}: {e}")


def place_order_and_set_native_stop(symbol, side, size, sl, tp):
    """Ø«Ø¨Øª Ù¾ÙˆØ²ÛŒØ´Ù† Ø§ØµÙ„ÛŒ Ùˆ Ø³Ù¾Ø³ Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´Ø§Øª SL Ùˆ TP Ø¯Ø± ØµØ±Ø§ÙÛŒ (ÙÙ‚Ø· Live Trading)."""
    global exchange
    if not LIVE_TRADING:
        return True, exchange.fetch_ticker(symbol)['last'], None, None

    close_side = 'sell' if side == 'LONG' else 'buy'
    open_side = 'buy' if side == 'LONG' else 'sell'
    market_info = MARKET_DATA.get(symbol, {})
    size = round(size, market_info.get('precision_amount', 4))

    try:
        # 1. Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡ Market
        open_order = exchange.create_order(symbol, 'market', open_side, size, None, {'leverage': LEVERAGE})
        entry_price = open_order['price'] if open_order['price'] else exchange.fetch_ticker(symbol)['last']
    except Exception as e:
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ù¾ÙˆØ²ÛŒØ´Ù† {symbol}: {e}")
        return False, 0.0, None, None

    sl_id, tp_id = None, None

    # 2. Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ SL (Stop-Loss)
    try:
        # Ø¯Ø± Coinex Ø§Ø² Ù†ÙˆØ¹ Limit Ø¨Ø§ StopPrice Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
        sl_order = exchange.create_order(symbol, 'limit', close_side, size, sl, {'stopLossPrice': sl})
        sl_id = sl_order['id']
    except Exception as e:
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ SL Ø¨Ø±Ø§ÛŒ {symbol}: {e}. Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§Ø² Ø§Ø³Øª!")

    # 3. Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ TP (Take-Profit)
    try:
        tp_order = exchange.create_order(symbol, 'limit', close_side, size, tp, {'takeProfitPrice': tp})
        tp_id = tp_order['id']
    except Exception as e:
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ TP Ø¨Ø±Ø§ÛŒ {symbol}: {e}. Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø§Ø² Ø§Ø³Øª!")

    return True, entry_price, sl_id, tp_id


def update_ledger_from_exchange_close(symbol, side, size, entry, exit_price, pnl, strategy, trade_id):
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ledger Ø¨Ø§ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ø§Ø² ØµØ±Ø§ÙÛŒ (ÙÙ‚Ø· Live Trading)."""
    global Daily_Stats, Symbol_Losses, Strategy_Stats, Ledger
    current_time = get_tehran_time()

    exit_reason = "ØªÙˆØ³Ø· ØµØ±Ø§ÙÛŒ/Ù†Ø§Ù…Ø´Ø®Øµ"
    if pnl > 0:
        exit_reason = "Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ø³ÙˆØ¯Ø¯Ù‡ (TP/SL Ù…ØªØ­Ø±Ú© ØªÙˆØ³Ø· ØµØ±Ø§ÙÛŒ)"
    elif pnl < 0:
        exit_reason = "SL (Ø­Ø¯ Ø¶Ø±Ø± ØªÙˆØ³Ø· ØµØ±Ø§ÙÛŒ)"

    update_capital_after_trade(pnl)

    Daily_Stats['Total PnL'] += pnl
    if pnl > 0: Daily_Stats['Wins'] += 1
    else:
        Daily_Stats['Losses'] += 1
        Symbol_Losses[symbol] += abs(pnl)

    total_trades = Daily_Stats['Wins'] + Daily_Stats['Losses']
    Daily_Stats['WinRate'] = (Daily_Stats['Wins'] / total_trades) * 100 if total_trades > 0 else 0

    if strategy in Strategy_Stats:
        Strategy_Stats[strategy]['PnL'] += pnl
        if pnl > 0: Strategy_Stats[strategy]['Win'] += 1
        else: Strategy_Stats[strategy]['Loss'] += 1

    telegram_msg = (
        f"**ğŸš€ğŸ›‘ Ù…Ø¹Ø§Ù…Ù„Ù‡ ØªÙˆØ³Ø· ØµØ±Ø§ÙÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯** (ID: {trade_id})\n"
        f"ğŸ“ˆ Ù†Ù…Ø§Ø¯: {symbol} ({side})\n"
        f"ğŸ”¬ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: **{strategy}**\n"
        f"ğŸ—“ï¸ Ø²Ù…Ø§Ù† Ø®Ø±ÙˆØ¬: {current_time}\n"
        f"ğŸšª Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬ (ØªØ®Ù…ÛŒÙ†): {round(exit_price, 4)}\n"
        f"ğŸ“Š Ù†ØªÛŒØ¬Ù‡: **{('âœ… WIN' if pnl > 0 else 'âŒ LOSS')}** ({exit_reason})\n"
        f"ğŸ’° Ø³ÙˆØ¯/Ø²ÛŒØ§Ù† Ù†Ù‡Ø§ÛŒÛŒ: **${round(pnl, 2)}**"
    )
    send_telegram_message(telegram_msg)
    save_state()

def sync_with_exchange():
    """Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ledger Ø¯Ø§Ø®Ù„ÛŒ Ø±Ø¨Ø§Øª Ø¨Ø§ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø² ÙˆØ§Ù‚Ø¹ÛŒ Ø¯Ø± ØµØ±Ø§ÙÛŒ."""
    global Ledger
    current_time = get_tehran_time()

    if not LIVE_TRADING:
        return

    try:
        # 1. Ø¯Ø±ÛŒØ§ÙØª Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ Ø¨Ø§Ø² Ø§Ø² ØµØ±Ø§ÙÛŒ
        positions = exchange.fetch_positions(SYMBOLS)
        real_open_symbols = {}
        for pos in positions:
            symbol = pos['symbol']
            contracts = float(pos.get('contracts', 0))
            if abs(contracts) > 0:
                side = 'LONG' if contracts > 0 else 'SHORT'
                real_open_symbols[symbol] = {
                   'entry_price': float(pos['entryPrice']),
                   'side': side,
                   'size': abs(contracts),
                   'pnl': float(pos['unrealizedPnl']),
                }

        symbols_to_delete = []
        for symbol, trade in list(Ledger.items()):

            # 2. Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª OPEN Ø¯Ø± Ledger Ú©Ù‡ Ø¯Ø± ØµØ±Ø§ÙÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯
            if trade['status'] == 'OPEN' and abs(trade['size']) > 0:
                is_open_in_exchange = False
                for pos in positions:
                     if pos['symbol'] == symbol and abs(float(pos.get('contracts', 0))) == trade['size']:
                        is_open_in_exchange = True
                        break

                if not is_open_in_exchange:
                    print(f"[{current_time}] ğŸš€ Ù¾ÙˆØ²ÛŒØ´Ù† {symbol} (ID:{trade.get('id')}) ØªÙˆØ³Ø· ØµØ±Ø§ÙÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯. Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ledger.")
                    try:
                        # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ ÛŒØ§ÙØªÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª PnL Ø§Ø² Ø¢Ø®Ø±ÛŒÙ† ØªØ±ÛŒØ¯ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡
                        closed_trade_info = exchange.fetch_my_trades(symbol, limit=1)
                        if closed_trade_info and closed_trade_info[0]['info'].get('deal_profit_pnl'):
                            exit_price = closed_trade_info[0]['price']
                            pnl = float(closed_trade_info[0]['info']['deal_profit_pnl'])
                            update_ledger_from_exchange_close(symbol, trade['side'], trade['size'], trade['entry'], exit_price, pnl, trade['strategy'], trade['id'])
                            symbols_to_delete.append(symbol)
                            cancel_all_native_orders(symbol)
                        else:
                            # Ø§Ú¯Ø± Ø§Ø·Ù„Ø§Ø¹Ø§Øª PnL Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ø¨ÙˆØ¯ØŒ ÙØ±Ø¶ Ø¨Ø± Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ù†Ø§Ù…Ø´Ø®Øµ (Unmanaged)
                            print(f"[{current_time}] âš ï¸ Ø¬Ø²Ø¦ÛŒØ§Øª PnL Ø¨Ø±Ø§ÛŒ {symbol} ÛŒØ§ÙØª Ù†Ø´Ø¯. Ù¾ÙˆØ²ÛŒØ´Ù† Ø§Ø² Ledger Ø­Ø°Ù Ø´Ø¯.")
                            symbols_to_delete.append(symbol)

                    except Exception as e:
                         print(f"[{current_time}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¬Ø²Ø¦ÛŒØ§Øª Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡ {symbol}: {e}")
                         symbols_to_delete.append(symbol)

        for symbol in symbols_to_delete:
            Ledger.pop(symbol, None)

        # 3. Ø§ÙØ²ÙˆØ¯Ù† Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø² Ø¯Ø± ØµØ±Ø§ÙÛŒ Ú©Ù‡ Ø¯Ø± Ledger Ù†ÛŒØ³ØªÙ†Ø¯ (Unmanaged)
        added_unmanaged_count = 0
        for symbol, pos_data in real_open_symbols.items():
            if symbol not in Ledger or Ledger[symbol]['status'] in ['CLOSED', 'PENDING']:
                Ledger[symbol] = {
                    'status': 'OPEN', 'side': pos_data['side'], 'size': pos_data['size'],
                    'entry': pos_data['entry_price'],
                    'sl': 0, 'tp': 0,
                    'initial_sl': 0, 'time_entry': current_time,
                    'strategy': 'UNMANAGED', 'id': 'UNMANAGED',
                    'margin': (pos_data['size'] * pos_data['entry_price']) / LEVERAGE,
                    'trades': []
                }
                added_unmanaged_count += 1
                send_telegram_message(f"**ğŸŸ  Ù¾ÙˆØ²ÛŒØ´Ù† Unmanaged ÛŒØ§ÙØª Ø´Ø¯**\n Ù†Ù…Ø§Ø¯: {symbol} ({pos_data['side']})")

        if added_unmanaged_count > 0 or symbols_to_delete:
            save_state()

    except Exception as e:
        error_details = traceback.format_exc()
        print(f"[{current_time}] âŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ ØµØ±Ø§ÙÛŒ: {e}")
        send_telegram_message(f"**âŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ**:\n Ø±Ø¨Ø§Øª Ù†ØªÙˆØ§Ù†Ø³Øª ÙˆØ¶Ø¹ÛŒØª ÙˆØ§Ù‚Ø¹ÛŒ Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ø² ØµØ±Ø§ÙÛŒ Ø¨Ú¯ÛŒØ±Ø¯. Ø¬Ø²Ø¦ÛŒØ§Øª: {error_details[:500]}...")


# --- ØªÙˆØ§Ø¨Ø¹ Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú© (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ) ---

def update_ledger_simulated(symbol, side, size, entry, sl, tp, status, strategy_type=None, trade_id=None, time_exit=None, sl_order_id=None, tp_order_id=None):
    """Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯ÙØªØ± Ú©Ù„ Ù…Ø¹Ø§Ù…Ù„Ø§Øª (Ledger) Ø¯Ø± Ø­Ø§Ù„Øª Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ/Live."""
    global Ledger, Daily_Stats, Symbol_Losses, Strategy_Stats
    current_time = get_tehran_time()

    if status == 'OPEN':
        global Trade_Counter
        Trade_Counter += 1

        margin_needed = round((size * entry) / LEVERAGE, 2)

        Ledger[symbol] = {
            'status': 'OPEN', 'side': side, 'size': size, 'entry': entry, 'sl': sl, 'tp': tp,
            'initial_sl': sl,
            'time_entry': current_time, 'strategy': strategy_type, 'id': Trade_Counter,
            'margin': margin_needed, 'trades': [],
            'sl_order_id': sl_order_id, 'tp_order_id': tp_order_id
        }

        print(f"[{current_time}] ğŸŸ¢ Ù…Ø¹Ø§Ù…Ù„Ù‡ {Trade_Counter} ({strategy_type} - {side}) Ø¯Ø± {symbol} Ø¨Ø§ Ù‚ÛŒÙ…Øª {round(entry, 4)} Ø¨Ø§Ø² Ø´Ø¯. SL: {round(sl, 4)} | TP: {round(tp, 4)}")

        telegram_msg = (
            f"**âœ… Ù¾ÙˆØ²ÛŒØ´Ù† Ø¬Ø¯ÛŒØ¯ Ø¨Ø§Ø² Ø´Ø¯** (ID: **{Trade_Counter}**)\n"
            f"ğŸ“ˆ Ù†Ù…Ø§Ø¯: {symbol} ({TIMEFRAME} - **{strategy_type}**)\n"
            f"â¬†ï¸/â¬‡ï¸ Ù†ÙˆØ¹: **{side}** ({'Live' if LIVE_TRADING else 'Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ'})\n"
            f"ğŸ’° Ø­Ø¬Ù… (Ø³Ø§ÛŒØ²): {round(size, 4)}\n"
            f"ğŸ’µ Ù‚ÛŒÙ…Øª ÙˆØ±ÙˆØ¯: {round(entry, 4)}\n"
            f"ğŸ›‘ SL: {round(sl, 4)} | ğŸ¯ TP: {round(tp, 4)}"
        )
        send_telegram_message(telegram_msg)
        save_state()

    elif status == 'CLOSED':
        trade = Ledger.pop(symbol, None)
        if trade is None or trade.get('status') == 'CLOSED': return

        exit_price = time_exit
        strategy = trade.get('strategy', 'Unknown')
        trade_id_sim = trade.get('id', 'N/A')

        pnl = 0
        if trade['side'] == 'LONG': pnl = (exit_price - trade['entry']) * trade['size']
        elif trade['side'] == 'SHORT': pnl = (trade['entry'] - exit_price) * trade['size']

        # Ù…Ù†Ø·Ù‚ Ø´ÙØ§Ùâ€ŒØ³Ø§Ø²ÛŒ Ø¯Ù„ÛŒÙ„ Ø®Ø±ÙˆØ¬ (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)
        exit_reason = ""
        TOLERANCE = 0.0001

        if pnl < 0:
            exit_reason = "SL (Ø­Ø¯ Ø¶Ø±Ø±)"
        elif pnl > 0:
            is_tp_hit = abs(exit_price - trade['tp']) < TOLERANCE
            is_trailing_sl_hit = abs(exit_price - trade['sl']) < TOLERANCE

            if is_tp_hit:
                exit_reason = "TP (Ø­Ø¯ Ø³ÙˆØ¯)"
            elif is_trailing_sl_hit or abs(exit_price - trade['initial_sl']) < TOLERANCE:
                exit_reason = "SL Ù…ØªØ­Ø±Ú© (Trailing Stop/BE)"
            else:
                exit_reason = "Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù† Ù…Ø§Ø±Ú©Øª (Ø³ÙˆØ¯Ø¯Ù‡/Ø¯Ø³ØªÛŒ)"
        else:
            exit_reason = "Ø®Ø±ÙˆØ¬ Ø³Ø± Ø¨Ù‡ Ø³Ø± (Breakeven)"
        # ---------------------------------------------


        update_capital_after_trade(pnl)

        Daily_Stats['Total PnL'] += pnl
        if pnl > 0: Daily_Stats['Wins'] += 1
        else:
            Daily_Stats['Losses'] += 1
            Symbol_Losses[symbol] += abs(pnl)

        total_trades = Daily_Stats['Wins'] + Daily_Stats['Losses']
        Daily_Stats['WinRate'] = (Daily_Stats['Wins'] / total_trades) * 100 if total_trades > 0 else 0

        if strategy in Strategy_Stats:
            Strategy_Stats[strategy]['PnL'] += pnl
            if pnl > 0: Strategy_Stats[strategy]['Win'] += 1
            else: Strategy_Stats[strategy]['Loss'] += 1

        telegram_msg = (
            f"**ğŸ›‘ Ù…Ø¹Ø§Ù…Ù„Ù‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯** (ID: **{trade_id_sim}**)\n"
            f"ğŸ“ˆ Ù†Ù…Ø§Ø¯: {symbol} ({trade['side']})\n"
            f"ğŸ”¬ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ: **{strategy}**\n"
            f"ğŸ—“ï¸ Ø²Ù…Ø§Ù† Ø®Ø±ÙˆØ¬: {current_time}\n"
            f"ğŸšª Ù‚ÛŒÙ…Øª Ø®Ø±ÙˆØ¬: {round(exit_price, 4)}\n"
            f"ğŸ“Š Ù†ØªÛŒØ¬Ù‡: **{('âœ… WIN' if pnl > 0 else 'âŒ LOSS')}** ({exit_reason})\n"
            f"ğŸ’° Ø³ÙˆØ¯/Ø²ÛŒØ§Ù†: **${round(pnl, 2)}**"
        )
        send_telegram_message(telegram_msg)
        save_state()

def check_trade_status(symbol, current_high, current_low):
    """Ø¨Ø±Ø±Ø³ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯Ù† SL/TP Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² (ÙÙ‚Ø· Ø¯Ø± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)."""
    trade = Ledger[symbol]

    if trade.get('strategy') == 'UNMANAGED': return

    # Check TP
    if trade['side'] == 'LONG' and current_high >= trade['tp']:
        update_ledger_simulated(symbol, trade['side'], trade['size'], trade['entry'], trade['sl'], trade['tp'], 'CLOSED', trade['strategy'], trade['id'], time_exit=trade['tp'])
        return
    if trade['side'] == 'SHORT' and current_low <= trade['tp']:
        update_ledger_simulated(symbol, trade['side'], trade['size'], trade['entry'], trade['sl'], trade['tp'], 'CLOSED', trade['strategy'], trade['id'], time_exit=trade['tp'])
        return

    # Check SL
    if trade['side'] == 'LONG' and current_low <= trade['sl']:
        update_ledger_simulated(symbol, trade['side'], trade['size'], trade['entry'], trade['sl'], trade['tp'], 'CLOSED', trade['strategy'], trade['id'], time_exit=trade['sl'])
        return
    if trade['side'] == 'SHORT' and current_high >= trade['sl']:
        update_ledger_simulated(symbol, trade['side'], trade['size'], trade['entry'], trade['sl'], trade['tp'], 'CLOSED', trade['strategy'], trade['id'], time_exit=trade['sl'])
        return


def manage_trailing_stop(symbol, current_price, current_atr, side):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø¯ Ø¶Ø±Ø± Ù…ØªØ­Ø±Ú© (Trailing Stop) (Ø¨Ø§ Ù…Ù†Ø·Ù‚ Ø¯Ø§Ø®Ù„ÛŒ Ø¯Ø± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ)."""
    global TRAILING_ATR_MULTIPLIER, TRAILING_R_ACTIVATION, TRAILING_BE_R_ACTIVATION
    global Ledger

    trade = Ledger[symbol]

    if trade.get('strategy') == 'UNMANAGED': return

    initial_sl = trade['initial_sl']
    current_sl = trade['sl']
    entry_price = trade['entry']

    risk_distance = abs(entry_price - initial_sl)

    profit_to_activate_be = TRAILING_BE_R_ACTIVATION * risk_distance
    profit_to_activate_trail = TRAILING_R_ACTIVATION * risk_distance
    trailing_distance = TRAILING_ATR_MULTIPLIER * current_atr # Ø¶Ø±ÛŒØ¨ 1.5

    new_sl = current_sl

    if side == 'LONG':
        current_profit = current_price - entry_price
        if current_profit >= profit_to_activate_be and current_sl < entry_price:
            new_sl = entry_price
        if current_profit >= profit_to_activate_trail:
            calculated_sl = current_price - trailing_distance
            if calculated_sl > current_sl:
                new_sl = calculated_sl

    elif side == 'SHORT':
        current_profit = entry_price - current_price
        if current_profit >= profit_to_activate_be and current_sl > entry_price:
            new_sl = entry_price
        if current_profit >= profit_to_activate_trail:
            calculated_sl = current_price + trailing_distance
            if calculated_sl < current_sl:
                new_sl = calculated_sl

    # Ø§Ø¹Ù…Ø§Ù„ ØªØºÛŒÛŒØ±Ø§Øª Ùˆ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¯Ø± Ledger (ÙÙ‚Ø· Ø§Ú¯Ø± ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø¨Ø§Ø´Ø¯)
    if new_sl != current_sl:
        precision = MARKET_DATA.get(symbol, {}).get('precision_price', 4)
        trade['sl'] = round(new_sl, precision)
        
        # ğŸ’¡ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ SL Ø¨ÙˆÙ…ÛŒ Ø¯Ø± ØµØ±Ø§ÙÛŒ (ÙÙ‚Ø· Live Trading)
        if LIVE_TRADING and trade.get('sl_order_id'):
            try:
                # 1. Ù„ØºÙˆ SL Ù‚Ø¯ÛŒÙ…ÛŒ
                cancel_all_native_orders(symbol) # Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø­Ø°Ù SL Ùˆ TP Ù‚Ø¨Ù„ÛŒ
                
                # 2. Ø«Ø¨Øª SL Ø¬Ø¯ÛŒØ¯
                close_side = 'sell' if side == 'LONG' else 'buy'
                size = trade['size']
                
                # ÙØ±Ø¶ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… TP Ù‡Ù†ÙˆØ² Ø¯Ø± Ledger Ù‡Ø³Øª Ùˆ Ø¢Ù† Ø±Ø§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø«Ø¨Øª Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
                tp = trade['tp'] 
                
                sl_order = exchange.create_order(symbol, 'limit', close_side, size, trade['sl'], {'stopLossPrice': trade['sl']})
                tp_order = exchange.create_order(symbol, 'limit', close_side, size, tp, {'takeProfitPrice': tp})
                
                trade['sl_order_id'] = sl_order['id']
                trade['tp_order_id'] = tp_order['id'] # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø¬Ø¯Ø¯ TP ID
                
                print(f"[{get_tehran_time()}] ğŸ”„ SL Ù…ØªØ­Ø±Ú© {symbol} Ø¨Ù‡ {round(new_sl, precision)} Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯.")
                save_state()
            except Exception as e:
                print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ SL Ø¨ÙˆÙ…ÛŒ {symbol}: {e}")
                
        # ğŸ’¡ Ø¯Ø± Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ ÙÙ‚Ø· Log Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ…
        elif not LIVE_TRADING:
            print(f"[{get_tehran_time()}] ğŸ”„ SL Ù…ØªØ­Ø±Ú© (Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ) {symbol} Ø¨Ù‡ {round(new_sl, precision)} Ø¨Ù‡â€ŒØ±ÙˆØ² Ø´Ø¯.")
            save_state()

# --------------------------------------------------------------------------
# ØªÙˆØ§Ø¨Ø¹ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ùˆ ÙÛŒÙ„ØªØ±Ù‡Ø§
# --------------------------------------------------------------------------

def check_long_term_trend(symbol, ohlcv_4h):
    """
    Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±ÙˆÙ†Ø¯ Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª (4 Ø³Ø§Ø¹ØªÙ‡) Ø¨Ø§ EMA.
    Ø®Ø±ÙˆØ¬ÛŒ: 'LONG', 'SHORT', 'NEUTRAL'
    """
    if len(ohlcv_4h) < LONG_TERM_EMA_PERIOD:
        return 'NEUTRAL'
    
    close_prices = pd.Series([x[4] for x in ohlcv_4h])
    ema = talib.EMA(close_prices.values, timeperiod=LONG_TERM_EMA_PERIOD)
    
    last_close = close_prices.iloc[-1]
    last_ema = ema[-1]
    
    if last_close > last_ema:
        return 'LONG'
    elif last_close < last_ema:
        return 'SHORT'
    return 'NEUTRAL'

def check_adx_filter(ohlcv_15m):
    """ÙÛŒÙ„ØªØ± Ù‚Ø¯Ø±Øª Ø±ÙˆÙ†Ø¯ Ø¨Ø§ ADX."""
    if len(ohlcv_15m) < ADX_PERIOD:
        return False, "Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª"
    
    high = pd.Series([x[2] for x in ohlcv_15m]).values
    low = pd.Series([x[3] for x in ohlcv_15m]).values
    close = pd.Series([x[4] for x in ohlcv_15m]).values
    
    adx = talib.ADX(high, low, close, timeperiod=ADX_PERIOD)
    current_adx = adx[-1]
    
    if current_adx >= ADX_MIN_LEVEL:
        return True, f"ADX Ù‚ÙˆÛŒ ({round(current_adx, 2)})"
    return False, f"ADX Ø¶Ø¹ÛŒÙ ({round(current_adx, 2)})"

def check_trend_breakout_signal(ohlcv):
    """
    Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø´Ú©Ø³Øª Ø±ÙˆÙ†Ø¯ (EMA 50).
    Ø®Ø±ÙˆØ¬ÛŒ: ('LONG', entry, sl, tp) ÛŒØ§ ('SHORT', entry, sl, tp) ÛŒØ§ None
    """
    if len(ohlcv) < EMA_TREND_PERIOD + ATR_PERIOD: return None

    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    
    # Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
    ema = talib.EMA(df['close'].values, timeperiod=EMA_TREND_PERIOD)
    atr = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=ATR_PERIOD)
    current_atr = atr[-1]
    
    # Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
    c0 = df.iloc[-1] # Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ
    c1 = df.iloc[-2] # Ú©Ù†Ø¯Ù„ Ù‚Ø¨Ù„
    
    # Ø³ÛŒÚ¯Ù†Ø§Ù„ Long: Ø´Ú©Ø³Øª ØµØ¹ÙˆØ¯ÛŒ EMA
    long_signal = (c1['close'] < ema[-2] and c0['close'] > ema[-1])
    
    # Ø³ÛŒÚ¯Ù†Ø§Ù„ Short: Ø´Ú©Ø³Øª Ù†Ø²ÙˆÙ„ÛŒ EMA
    short_signal = (c1['close'] > ema[-2] and c0['close'] < ema[-1])
    
    if long_signal:
        entry = c0['close']
        sl = c0['low'] - (0.5 * current_atr) # SL Ø²ÛŒØ± low Ú©Ù†Ø¯Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„
        risk_distance = entry - sl
        tp = entry + (risk_distance * 1.5) # R:R 1.5
        return 'LONG', entry, sl, tp, current_atr, "TrendBreakout"

    if short_signal:
        entry = c0['close']
        sl = c0['high'] + (0.5 * current_atr) # SL Ø¨Ø§Ù„Ø§ÛŒ high Ú©Ù†Ø¯Ù„ Ø³ÛŒÚ¯Ù†Ø§Ù„
        risk_distance = sl - entry
        tp = entry - (risk_distance * 1.5) # R:R 1.5
        return 'SHORT', entry, sl, tp, current_atr, "TrendBreakout"
    
    return None

def check_spt_signal(ohlcv):
    """
    Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Spike Price Trigger (SPT) ÛŒØ§ Liquidation Flush.
    Ø®Ø±ÙˆØ¬ÛŒ: ('LONG', entry, sl, tp) ÛŒØ§ ('SHORT', entry, sl, tp) ÛŒØ§ None
    """
    if len(ohlcv) < ATR_PERIOD + 2: return None
    
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    
    # Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
    atr = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=ATR_PERIOD)
    avg_volume = df['volume'].rolling(window=VOLUME_AVG_PERIOD).mean()
    current_atr = atr[-1]
    
    # Ú©Ù†Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
    c0 = df.iloc[-1] # Ú©Ù†Ø¯Ù„ ÙØ¹Ù„ÛŒ (Ú©Ù‡ Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ø²Ú¯Ø´Øª Ø±Ø§ ØªØ£ÛŒÛŒØ¯ Ú©Ù†Ø¯)
    c1 = df.iloc[-2] # Ú©Ù†Ø¯Ù„ ÙÙ„Ø§Ø´ (Spike/Flush)
    
    avg_vol = avg_volume.iloc[-2]
    
    # ÙÛŒÙ„ØªØ± Ø­Ø¬Ù…: Volume Ú©Ù†Ø¯Ù„ ÙÙ„Ø§Ø´ Ø¨Ø§ÛŒØ¯ Ø§Ø² Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ø¨ÛŒØ´ØªØ± Ø¨Ø§Ø´Ø¯
    volume_ok = c1['volume'] > (avg_vol * MIN_VOLUME_MULTIPLIER)
    if not volume_ok: return None

    # ÙÛŒÙ„ØªØ± Ø¨Ø¯Ù†Ù‡/Ø´Ø¯Ùˆ Spike (C1)
    c1_range = c1['high'] - c1['low']
    c1_body = abs(c1['close'] - c1['open'])
    
    # ÙÛŒÙ„ØªØ± Ø¨Ø±Ú¯Ø´Øª (C0)
    c0_body = abs(c0['close'] - c0['open'])
    
    # Ø³ÛŒÚ¯Ù†Ø§Ù„ Long: ÙÙ„Ø§Ø´ Ù†Ø²ÙˆÙ„ÛŒ + Ø¨Ø±Ú¯Ø´Øª Ù‚ÙˆÛŒ ØµØ¹ÙˆØ¯ÛŒ
    if c1['close'] < c1['open']: # Ú©Ù†Ø¯Ù„ Ù†Ø²ÙˆÙ„ÛŒ
        lower_shadow = c1['open'] - c1['low']
        
        # 1. Ú©Ù†Ø¯Ù„ C1 Ø¨Ø§ÛŒØ¯ ÛŒÚ© ÙÙ„Ø§Ø´ Ù†Ø²ÙˆÙ„ÛŒ Ø¨Ø§Ø´Ø¯ (Ø´Ø¯Ùˆ Ù¾Ø§ÛŒÛŒÙ† Ø­Ø¯Ø§Ù‚Ù„ 3 Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø¯Ù†Ù‡)
        is_long_flush = lower_shadow > (c1_body * SPIKE_BODY_MULTIPLIER)
        
        # 2. Ú©Ù†Ø¯Ù„ C0 Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ø¨Ø±Ú¯Ø´Øª Ù‚ÙˆÛŒ ØµØ¹ÙˆØ¯ÛŒ Ø¨Ø§Ø´Ø¯ (Ø­Ø¯Ø§Ù‚Ù„ 50% Ø§Ø² Ø±Ù†Ø¬ C1)
        is_long_confirmation = (c0_body >= c1_range * SMART_ENTRY_RETRA_RATIO) and (c0['close'] > c0['open'])
        
        if is_long_flush and is_long_confirmation:
            entry = c0['close']
            sl = c1['low'] - (0.5 * current_atr) # SL Ø²ÛŒØ± Ù¾Ø§ÛŒÛŒÙ†â€ŒØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ ÙÙ„Ø§Ø´
            risk_distance = entry - sl
            tp = entry + (risk_distance * SPT_RR_RATIO)
            return 'LONG', entry, sl, tp, current_atr, "SPT"

    # Ø³ÛŒÚ¯Ù†Ø§Ù„ Short: ÙÙ„Ø§Ø´ ØµØ¹ÙˆØ¯ÛŒ + Ø¨Ø±Ú¯Ø´Øª Ù‚ÙˆÛŒ Ù†Ø²ÙˆÙ„ÛŒ
    if c1['close'] > c1['open']: # Ú©Ù†Ø¯Ù„ ØµØ¹ÙˆØ¯ÛŒ
        upper_shadow = c1['high'] - c1['close']
        
        # 1. Ú©Ù†Ø¯Ù„ C1 Ø¨Ø§ÛŒØ¯ ÛŒÚ© ÙÙ„Ø§Ø´ ØµØ¹ÙˆØ¯ÛŒ Ø¨Ø§Ø´Ø¯ (Ø´Ø¯Ùˆ Ø¨Ø§Ù„Ø§ Ø­Ø¯Ø§Ù‚Ù„ 3 Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø¯Ù†Ù‡)
        is_short_flush = upper_shadow > (c1_body * SPIKE_BODY_MULTIPLIER)
        
        # 2. Ú©Ù†Ø¯Ù„ C0 Ø¨Ø§ÛŒØ¯ ÛŒÚ© Ø¨Ø±Ú¯Ø´Øª Ù‚ÙˆÛŒ Ù†Ø²ÙˆÙ„ÛŒ Ø¨Ø§Ø´Ø¯ (Ø­Ø¯Ø§Ù‚Ù„ 50% Ø§Ø² Ø±Ù†Ø¬ C1)
        is_short_confirmation = (c0_body >= c1_range * SMART_ENTRY_RETRA_RATIO) and (c0['close'] < c0['open'])
        
        if is_short_flush and is_short_confirmation:
            entry = c0['close']
            sl = c1['high'] + (0.5 * current_atr) # SL Ø¨Ø§Ù„Ø§ÛŒ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ù†Ù‚Ø·Ù‡ ÙÙ„Ø§Ø´
            risk_distance = sl - entry
            tp = entry - (risk_distance * SPT_RR_RATIO)
            return 'SHORT', entry, sl, tp, current_atr, "SPT"

    return None

def process_symbol(symbol):
    """Ù…Ù†Ø·Ù‚ Ø§ØµÙ„ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù‡Ø± Ù†Ù…Ø§Ø¯."""
    global last_candle_timestamp, current_candle, LONG_TERM_TRENDS

    # 1. Ú†Ú© Ú©Ø±Ø¯Ù† Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§
    if symbol in Ledger:
        # Ø¯Ø± Ø­Ø§Ù„Øª LiveØŒ Ú†Ú© Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ø¯Ø±ÙˆÙ†ÛŒ ÙÙ‚Ø· Ø¨Ø±Ø§ÛŒ Trailng Stop Ùˆ SL/TP Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³Øª
        if not LIVE_TRADING:
           check_trade_status(symbol, current_candle['high'], current_candle['low'])
        
        manage_trailing_stop(symbol, current_candle['close'], current_candle['atr'], Ledger[symbol]['side'])
        return

    if len(Ledger) >= MAX_CONCURRENT_TRADES:
        # print(f"[{get_tehran_time()}] âš ï¸ {symbol}: Ø³Ù‚Ù Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø§Ø² ({MAX_CONCURRENT_TRADES}) Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³Øª.")
        return

    # 2. Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ OHLCV
    try:
        # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§ÛŒÙ… ÙØ±ÛŒÙ… Ø§ØµÙ„ÛŒ (15m)
        ohlcv = exchange.fetch_ohlcv(symbol, TIMEFRAME, limit=OHLCV_LIMIT)
        if not ohlcv or len(ohlcv) < 100:
            print(f"[{get_tehran_time()}] âš ï¸ Ø¯Ø§Ø¯Ù‡ Ú©Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ {symbol} ÛŒØ§ÙØª Ù†Ø´Ø¯.")
            return

        # Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø²Ù…Ø§Ù† Ø¢Ø®Ø±ÛŒÙ† Ú©Ù†Ø¯Ù„
        current_candle_timestamp = ohlcv[-1][0]
        if symbol not in last_candle_timestamp or last_candle_timestamp[symbol] != current_candle_timestamp:
            last_candle_timestamp[symbol] = current_candle_timestamp
            is_new_candle = True
        else:
            is_new_candle = False

        if not is_new_candle:
            # Ø±Ø¨Ø§Øª ÙÙ‚Ø· Ø±ÙˆÛŒ Ú©Ù†Ø¯Ù„ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡ ØªØµÙ…ÛŒÙ… Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯
            return
        
        # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§ÛŒÙ… ÙØ±ÛŒÙ… Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª (4h)
        ohlcv_4h = exchange.fetch_ohlcv(symbol, TREND_TIMEFRAME, limit=LONG_TERM_EMA_PERIOD + 2)
        if not ohlcv_4h or len(ohlcv_4h) < LONG_TERM_EMA_PERIOD:
            long_term_trend = 'NEUTRAL'
        else:
            long_term_trend = check_long_term_trend(symbol, ohlcv_4h)
        LONG_TERM_TRENDS[symbol] = long_term_trend

        # Ø§Ù†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÛŒØ³Ú©
        df_15m = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        atr = talib.ATR(df_15m['high'].values, df_15m['low'].values, df_15m['close'].values, timeperiod=ATR_PERIOD)
        adx = talib.ADX(df_15m['high'].values, df_15m['low'].values, df_15m['close'].values, timeperiod=ADX_PERIOD)

        current_candle = {
            'close': df_15m['close'].iloc[-1],
            'high': df_15m['high'].iloc[-1],
            'low': df_15m['low'].iloc[-1],
            'atr': atr[-1],
            'adx': adx[-1]
        }
        
        # 3. Ø¨Ø±Ø±Ø³ÛŒ ÙÛŒÙ„ØªØ± ADX
        is_adx_ok, adx_reason = check_adx_filter(ohlcv)
        if not is_adx_ok:
            # print(f"[{get_tehran_time()}] ğŸ›‘ {symbol}: ÙÛŒÙ„ØªØ± ADX ÙØ¹Ø§Ù„ Ø´Ø¯. ({adx_reason})")
            return
            
        # 4. Ø¨Ø±Ø±Ø³ÛŒ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§
        signal = None
        
        # Ø§ÙˆÙ„ÙˆÛŒØª Ø¨Ø§ SPT (ÙÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ Ù†Ù‚Ø¯ÛŒÙ†Ú¯ÛŒ)
        spt_result = check_spt_signal(ohlcv)
        if spt_result:
             signal = spt_result
             
        # Ø³Ù¾Ø³ Trend Breakout
        if not signal:
             signal = check_trend_breakout_signal(ohlcv)

        if not signal:
            return

        side, entry, sl, tp, current_atr, strategy_type = signal

        # 5. Ú†Ú© Ú©Ø±Ø¯Ù† ÙÛŒÙ„ØªØ± Ø±ÙˆÙ†Ø¯ Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª
        if long_term_trend != 'NEUTRAL' and long_term_trend != side:
            print(f"[{get_tehran_time()}] ğŸ›‘ {symbol} Ø³ÛŒÚ¯Ù†Ø§Ù„ {side} Ø¨Ø§ Ø±ÙˆÙ†Ø¯ Ø¨Ù„Ù†Ø¯Ù…Ø¯Øª {long_term_trend} Ù…ØºØ§ÛŒØ±Øª Ø¯Ø§Ø±Ø¯.")
            return

        # 6. ÙÛŒÙ„ØªØ± Ù‡Ù…Ø¨Ø³ØªÚ¯ÛŒ
        is_corr_ok, corr_reason = check_correlation_filter(symbol, side)
        if not is_corr_ok:
            print(f"[{get_tehran_time()}] ğŸ›‘ {symbol}: ÙÛŒÙ„ØªØ± Ù‡Ù…Ø¨Ø³ØªÚ¯ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯. ({corr_reason})")
            return
            
        # 7. Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø§ÛŒØ² Ù¾ÙˆØ²ÛŒØ´Ù†
        size = calculate_position_size(symbol, entry, sl, RISK_AMOUNT)
        if size == 0.0:
            print(f"[{get_tehran_time()}] ğŸ›‘ {symbol}: Ø³Ø§ÛŒØ² Ù¾ÙˆØ²ÛŒØ´Ù† ØµÙØ± Ø§Ø³Øª (Ø±ÛŒØ³Ú© Ø²ÛŒØ§Ø¯ ÛŒØ§ Ù…Ø§Ø±Ø¬ÛŒÙ† Ù†Ø§Ú©Ø§ÙÛŒ).")
            return
            
        # 8. Ø§Ø¬Ø±Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ù‡
        if LIVE_TRADING:
            # Live Trading: Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ Market Ùˆ Ø³Ù¾Ø³ SL/TP Ø¨ÙˆÙ…ÛŒ
            success, final_entry, sl_id, tp_id = place_order_and_set_native_stop(symbol, side, size, sl, tp)
            if success:
                 update_ledger_simulated(symbol, side, size, final_entry, sl, tp, 'OPEN', strategy_type, sl_order_id=sl_id, tp_order_id=tp_id)
            else:
                 print(f"[{get_tehran_time()}] âŒ {symbol}: Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø³ÙØ§Ø±Ø´ Live Trading.")

        else:
            # Simulated Trading
            update_ledger_simulated(symbol, side, size, entry, sl, tp, 'OPEN', strategy_type)


    except Exception as e:
        error_details = traceback.format_exc()
        print(f"[{get_tehran_time()}] âŒ Ø®Ø·Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ {symbol}: {e}")
        # send_telegram_message(f"âŒ Ø®Ø·Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ {symbol}:\n{error_details[:500]}...")


def main_loop():
    """Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª."""
    global LAST_REPORT_DATE, EXCHANGE_CONNECTED
    
    # 1. Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ùˆ Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ
    load_state()

    # 2. Ø¨Ø±Ø±Ø³ÛŒ Ø±ÛŒØ³Øª Ø±ÙˆØ²Ø§Ù†Ù‡ (Ú¯Ø²Ø§Ø±Ø´ Ùˆ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø±)
    current_date = get_tehran_time().split(' ')[0]
    if LAST_REPORT_DATE != current_date:
        if LAST_REPORT_DATE is not None:
             report = get_strategy_performance_report()
             send_telegram_message(report)
        reset_daily_stats()
        
    # 3. Ø¨Ø±Ø±Ø³ÛŒ Ø³Ù‚Ù Ø²ÛŒØ§Ù† Ø±ÙˆØ²Ø§Ù†Ù‡
    check_max_daily_loss()
    
    # 4. Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
    if not MARKET_DATA:
        if not load_market_params():
             return # Ø§Ú¯Ø± Ù†ØªÙˆØ§Ù†Ø³Øª Ù…ØªØµÙ„ Ø´ÙˆØ¯ØŒ Ù…ØªÙˆÙ‚Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯.
             
    # 5. Ù‡Ù…Ú¯Ø§Ù…â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø§ ØµØ±Ø§ÙÛŒ (ÙÙ‚Ø· Live Trading)
    sync_with_exchange()


    print(f"\n--- Ø´Ø±ÙˆØ¹ Ú†Ø±Ø®Ù‡ Ø¬Ø¯ÛŒØ¯ Ø¯Ø± {get_tehran_time()} (Ø¨Ø§Ø²: {len(Ledger)}/{MAX_CONCURRENT_TRADES}) ---")
    
    # 6. Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†Ù…Ø§Ø¯Ù‡Ø§
    for symbol in SYMBOLS:
        process_symbol(symbol)
        time.sleep(1) # ØªØ§Ø®ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Rate Limit

    print(f"--- Ú†Ø±Ø®Ù‡ Ú©Ø§Ù…Ù„ Ø´Ø¯. ---")


if __name__ == '__main__':
    print(f"==================================================")
    print(f"ğŸš€ Ø±Ø¨Ø§Øª ØªØ±ÛŒØ¯ÛŒÙ†Ú¯ Ú©ÙˆÛŒÙ†Ú©Ø³ - Ø´Ø±ÙˆØ¹ Ø¨Ù‡ Ú©Ø§Ø±")
    print(f"ğŸ“… Ø²Ù…Ø§Ù† ØªÙ‡Ø±Ø§Ù†: {get_tehran_time()}")
    print(f"âš™ï¸ ÙˆØ¶Ø¹ÛŒØª: {'âœ… Live' if LIVE_TRADING else 'ğŸ’¡ Simulated (Test)'}")
    print(f"==================================================")
    
    # Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ
    while True:
        try:
            main_loop()
        except Exception as e:
            error_details = traceback.format_exc()
            print(f"âŒ Ø®Ø·Ø§ÛŒ Ù†Ø§Ø´Ù†Ø§Ø®ØªÙ‡ Ø¯Ø± Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ: {e}")
            send_telegram_message(f"**âŒ Ø®Ø·Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ø¯Ø± Ø­Ù„Ù‚Ù‡ Ø§ØµÙ„ÛŒ:**\n{error_details[:500]}...")
            time.sleep(30) # ØªØ§Ø®ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø­Ù„Ù‚Ù‡ Ø®Ø·Ø§
        
        # ØªØ§Ø®ÛŒØ± Ø¨ÛŒÙ† Ù‡Ø± Ú†Ø±Ø®Ù‡ (Ø¨Ø³ØªÙ‡ Ø¨Ù‡ ØªØ§ÛŒÙ… ÙØ±ÛŒÙ…)
        time.sleep(30) # 30 Ø«Ø§Ù†ÛŒÙ‡